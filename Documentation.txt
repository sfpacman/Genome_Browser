Frontend 
The frontend is divided into two parts: HTML and CGI scripts. In HTML folder, the static webpages are stored (index page) along with multimedia objects. In the CGI folder the dynamic webpage is be stored in the form of Python script and HTML template (jinja2). Python script will access API functions from the middlelayer folder to retrive and process information based on the user input query from the index page. Both HTML and CSS markup are used for all of the webpage. Particuraly,bootstrap is used extenstly for producing mobile friendly webpags.   
HTML:
 the Index webpage is stored under this folder in which javascript (Jquery) enables displaying summary table based on user input.  
CGI:
 Instead of printing html code, a template module (JinJa2) is used to produced complex html page for the dynamic webpage (details page, summary table on the details page). All template html files are under template folder under CGI
The code for the webpage is HTML and is in the file index.html, the CGI uses a Python script, the codon table CGI is in the file table.py
 Three python scripts are developed for displaying data: 
summary.py is used for making the summary table on the list index in which users can access detail infromation throught the link:
summary.py uses findAPI.find_summary to retrive informatian based on user input data (gene name[DNA/ID] , protein product[protein], gene accession[gc], chromosome location[cl] )

compute_function.py is a collection of utility functions to display data based on the API functions results:
 markup is a function that insert a particular tag into a string ( good for highlighting sequecing region or indictate restriction enzyme site) 
 codon_usage is a object that can store and display codon usuage analysis in a html table form (in the combination of table.html). 
The details.py is used for making details.html and allow user to highlight coding region, get the restriction enzyme site of The selected sequence and caculate the codon usage analysis which will access the following API function:
 details.py used  findAPI.find_exon() to get a posistion list of exon boundary loaction  
 details.py used both Overallfq.py and codon_freq.py to caculate the codon usage frequency in a python dicitonary form.
 details.py used REnz.py to get a posistion list of restriction enzyme size based on the input sequence
 
The dummydata.py is used for producing phony data to test the above-mentioned functions by supply correspoding data. 
How the results were displayed in CGI scripts….




Database:
 
Figure 1: Schema for the Chromosome 8
Table description for database:
-- Table sc001.Gene
  Protein_product CHAR(50) NOT NULL,
  Genbank_Accession VARCHAR(10) NOT NULL,
  Chromosome_location VARCHAR(20) NOT NULL,
  Gene_name VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Genbank_Accession`)
  
-- Table sc001.Sequence
  DNA_sequence LONGTEXT NOT NULL,
  Amino_Acid_Seq MEDIUMTEXT NOT NULL,
  Gene_Identifier VARCHAR(45) NOT NULL,
  INDEX `fk_Sequence_Gene_idx` (Gene_Identifier ASC),
##Gene identifier is the Genbank accession number as its filled in all the records 
 PRIMARY KEY (Gene_Identifier),
    FOREIGN KEY (Gene_Identifier) 
    
-- Table `sc001`.`Exon`
  Exon_Start VARCHAR(45) NOT NULL,
  Exon_End VARCHAR(45) NOT NULL,
##Sequence_Gene_Identifier is the Genbank accession number as its filled in all the records 
  Sequence_Gene_Identifier VARCHAR(45) NOT NULL,
  ## to ensure multiple exons are still linked to the right gene
  exon_ID INT NOT NULL AUTO_INCREMENT,
## Foreign key to link to Gene
  INDEX `fk_Exon_Sequence1_idx` (`Sequence_Gene_Identifier` ASC), 
PRIMARY KEY (exon_ID))

-- Table sc001.Restriction_Enzyme
  idRestriction_Enzyme VARCHAR(7) NOT NULL,
  Recognition_seq MEDIUMTEXT NOT NULL,
## stand-alone table so primary key is the restriction enzyme ID
  PRIMARY KEY (`idRestriction_Enzyme`)
  
Parsing:
The parsing code uses functions imported from the Biopython’s module Genbank and iterates through each record one at a time extracting all of the wanted pieces of information to a dictionary. At the end of the parsing the dictionary is inserted into a main list with each of the relevant pieces of information associated with one gene. A separate dictionary was created for the restriction enzymes as they aren’t dependent on the genes. 
Populating:
MySQL connector driver was used to connect the MySQL statements to the database to populate with Python. The parsed entries in the list are assigned to values to input into the SQL statements to then populate the database in the correct tables and columns with the appropriate records for each gene. The python coding for the exon table was adjusted to ensure the allowance for multiple entries. 

