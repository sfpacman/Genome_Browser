The frontend is divided into two parts: HTML and CGI scripts. In HTML folder the static webpage will be stored (index page) along with multimedia objects. In the CGI folder the dynamic webpage is be stored in the form of Python script and HTML template (jinja2).

The code for the webpage is HTML and is in the file index.html, the CGI uses a Python script, the codon table CGI is in the file table.py
The summary list index is in the file summary.py
The detail page CGI is in the file details.py
The middle layer code that was accessed was….
How the results were displayed in CGI scripts….
The semantic markup that was used was HTML markup tags



Database:
 
Figure 1: Schema for the Chromosome 8
Table description for database:
-- Table sc001.Gene
  Protein_product CHAR(50) NOT NULL,
  Genbank_Accession VARCHAR(10) NOT NULL,
  Chromosome_location VARCHAR(20) NOT NULL,
  Gene_name VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Genbank_Accession`)
  
-- Table sc001.Sequence
  DNA_sequence LONGTEXT NOT NULL,
  Amino_Acid_Seq MEDIUMTEXT NOT NULL,
  Gene_Identifier VARCHAR(45) NOT NULL,
  INDEX `fk_Sequence_Gene_idx` (Gene_Identifier ASC),
##Gene identifier is the Genbank accession number as its filled in all the records 
 PRIMARY KEY (Gene_Identifier),
    FOREIGN KEY (Gene_Identifier) 
    
-- Table `sc001`.`Exon`
  Exon_Start VARCHAR(45) NOT NULL,
  Exon_End VARCHAR(45) NOT NULL,
##Sequence_Gene_Identifier is the Genbank accession number as its filled in all the records 
  Sequence_Gene_Identifier VARCHAR(45) NOT NULL,
  ## to ensure multiple exons are still linked to the right gene
  exon_ID INT NOT NULL AUTO_INCREMENT,
## Foreign key to link to Gene
  INDEX `fk_Exon_Sequence1_idx` (`Sequence_Gene_Identifier` ASC), 
PRIMARY KEY (exon_ID))

-- Table sc001.Restriction_Enzyme
  idRestriction_Enzyme VARCHAR(7) NOT NULL,
  Recognition_seq MEDIUMTEXT NOT NULL,
## stand-alone table so primary key is the restriction enzyme ID
  PRIMARY KEY (`idRestriction_Enzyme`)
  
Parsing:
The parsing code uses functions imported from the Biopython’s module Genbank and iterates through each record one at a time extracting all of the wanted pieces of information to a dictionary. At the end of the parsing the dictionary is inserted into a main list with each of the relevant pieces of information associated with one gene. A separate dictionary was created for the restriction enzymes as they aren’t dependent on the genes. 
Populating:
MySQL connector driver was used to connect the MySQL statements to the database to populate with Python. The parsed entries in the list are assigned to values to input into the SQL statements to then populate the database in the correct tables and columns with the appropriate records for each gene. The python coding for the exon table was adjusted to ensure the allowance for multiple entries. 

